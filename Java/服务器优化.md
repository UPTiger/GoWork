-----------------------------------------------------------------------------------------------

在linux终端中输入**ulimit -a**

“open files”参数选项后面的数值就是当前系统支持的最大打开文件数

**修改linux最大文件打开数**

如果要修改linux最大文件打开数，可以通过如下图参数命令 ulimit -n 后面接需要设置的文件数量。

设置好之后，再次查看 ulimit -a 你会发现已经设置为新的数量了

ulimit -a 4096设置文件打开数

/etc/init.d/umail_dovecot restart

{vim /etc/security/limits.conf   最后两行增加

1. - - nproc           4096000  
2. - - nofile          409600  }

{除此之外，如果针对不同的用户。也可以通过编辑修改 **/etc/rc.local**文件设置环境变量，添加 ulimit -n }

{vi /etc/systemd/system.conf 

DefaultLimitNOFILE=4096000      #这里需要修改 

DefaultLimitNPROC=4096000   #这里也需要修改 

reboot

ulimit -a  }

------

**查看进程打开文件数** 如果需要查看所有进程的文件打开数，如下图命令**lsof |wc -l** 

**查看系统句柄文件数** 当前系统文件句柄的最大数目，只用于查看，不能设置修改

**cat /proc/sys/fs/file-max**

--------------------------------------------------------------------------------------------------------------



这个命令会输出类似下面的结果：
LAST_ACK 16
SYN_RECV 348
ESTABLISHED 70
FIN_WAIT1 229
FIN_WAIT2 30
CLOSING 33
TIME_WAIT 18098
我们只用关心TIME_WAIT的个数，在这里可以看到，有18000多个TIME_WAIT，这样就占用了18000多个端口。要知道端口的数量只有65535个，占用一个少一个，会严重的影响到后继的新连接。这种情况下，我们就有必要调整下Linux的TCP内核参数，让系统更快的释放TIME_WAIT连接。

用vim打开配置文件：#vim /etc/sysctl.conf

在这个文件中，加入下面的几行内容：
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_fin_timeout = 30

输入下面的命令，让内核参数生效：#sysctl -p

简单的说明上面的参数的含义：

在经过这样的调整之后，除了会进一步提升服务器的负载能力之外，还能够防御小流量程度的DoS、CC和SYN攻击。

此外，如果你的连接数本身就很多，我们可以再优化一下TCP的可使用端口范围，进一步提升服务器的并发能力。依然是往上面的参数文件中，加入下面这些配置：
net.ipv4.tcp_keepalive_time = 1200
net.ipv4.ip_local_port_range = 10000 65000
net.ipv4.tcp_max_syn_backlog = 8192
net.ipv4.tcp_max_tw_buckets = 5000
\#这几个参数，建议只在流量非常大的服务器上开启，会有显著的效果。一般的流量小的服务器上，没有必要去设置这几个参数。

**内核其他TCP参数说明：**
net.ipv4.tcp_max_syn_backlog = 65536
\#记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。
net.core.netdev_max_backlog = 32768
\#每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。
net.core.somaxconn = 32768
\#web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。

net.ipv4.tcp_wmem = 8192 436600 873200
\# TCP写buffer,可参考的优化值: 8192 436600 873200
net.ipv4.tcp_rmem  = 32768 436600 873200
\# TCP读buffer,可参考的优化值: 32768 436600 873200
net.ipv4.tcp_mem = 94500000 91500000 92700000
\# 同样有3个值,意思是:
net.ipv4.tcp_mem[0]:低于此值，TCP没有内存压力。
net.ipv4.tcp_mem[1]:在此值下，进入内存压力阶段。
net.ipv4.tcp_mem[2]:高于此值，TCP拒绝分配socket。
上述内存单位是页，而不是字节。可参考的优化值是:786432 1048576 1572864

net.ipv4.tcp_max_orphans = 3276800
\#系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。
如果超过这个数字，连接将即刻被复位并打印出警告信息。
这个限制仅仅是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值，
更应该增加这个值(如果增加了内存之后)。
net.ipv4.tcp_fin_timeout = 30
\#如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。

经过这样的优化配置之后，你的服务器的TCP并发处理能力会显著提高。以上配置仅供参考，用于生产环境请根据自己的实际情况。

---------------------内存过多--

# Linux服务器Cache占用过多内存导致系统内存不足最终java应用程序崩溃解决方案

https://blog.csdn.net/u014740338/article/details/66975550

1、编写shell定时任务脚本freemem.sh

#! /bin/sh
used=`free -m | awk 'NR==2' | awk '{print $3}'`
free=`free -m | awk 'NR==2' | awk '{print $4}'`
echo "===========================" >> /data/data/memory/logs/mem.log
date >> /data/data/memory/logs/mem.log
echo "Memory usage before | [Use：${used}MB][Free：${free}MB]" >> /data/data/memory/logs/mem.log
if [ $free -le 4000 ] ; then
                sync && echo 1 > /proc/sys/vm/drop_caches
                sync && echo 2 > /proc/sys/vm/drop_caches
                sync && echo 3 > /proc/sys/vm/drop_caches
				used_ok=`free -m | awk 'NR==2' | awk '{print $3}'`
				free_ok=`free -m | awk 'NR==2' | awk '{print $4}'`
				echo "Memory usage after | [Use：${used_ok}MB][Free：${free_ok}MB]" >> /data/data/memory/logs/mem.log
                echo "OK" >> /data/data/memory/logs/mem.log
else
                echo "Not required" >> /data/data/memory/logs/mem.log
fi
exit 1

开启Linux定时任务crond，每天早上检查一次free内存，当小于4G时执行这三条命令（注：系统内容20G）。

2、使用crontab -e命令编辑当前用户的crontab

0 6 * * * /usr/local/tomcat/sztFileFront/bin/freemem.sh